/* esm.sh - @noble/hashes@1.7.1/utils */
var u=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function w(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function c(t,...e){if(!w(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function U(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function O(t){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}function T(t){return new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4))}function k(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function S(t,e){return t<<32-e|t>>>e}function V(t,e){return t<<e|t>>>32-e>>>0}var x=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function d(t){return t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255}var _=x?t=>t:t=>d(t);function j(t){for(let e=0;e<t.length;e++)t[e]=d(t[e])}var b=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function I(t){c(t);let e="";for(let r=0;r<t.length;r++)e+=b[t[r]];return e}var f={_0:48,_9:57,A:65,F:70,a:97,f:102};function l(t){if(t>=f._0&&t<=f._9)return t-f._0;if(t>=f.A&&t<=f.F)return t-(f.A-10);if(t>=f.a&&t<=f.f)return t-(f.a-10)}function C(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);let e=t.length,r=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);let n=new Uint8Array(r);for(let o=0,i=0;o<r;o++,i+=2){let p=l(t.charCodeAt(i)),a=l(t.charCodeAt(i+1));if(p===void 0||a===void 0){let g=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+g+'" at index '+i)}n[o]=p*16+a}return n}var h=async()=>{};async function D(t,e,r){let n=Date.now();for(let o=0;o<t;o++){r(o);let i=Date.now()-n;i>=0&&i<e||(await h(),n+=i)}}function m(t){if(typeof t!="string")throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array(new TextEncoder().encode(t))}function s(t){return typeof t=="string"&&(t=m(t)),c(t),t}function F(...t){let e=0;for(let n=0;n<t.length;n++){let o=t[n];c(o),e+=o.length}let r=new Uint8Array(e);for(let n=0,o=0;n<t.length;n++){let i=t[n];r.set(i,o),o+=i.length}return r}var y=class{clone(){return this._cloneInto()}};function H(t,e){if(e!==void 0&&{}.toString.call(e)!=="[object Object]")throw new Error("Options should be object or undefined");return Object.assign(t,e)}function R(t){let e=n=>t().update(s(n)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}function W(t){let e=(n,o)=>t(o).update(s(n)).digest(),r=t({});return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=n=>t(n),e}function v(t){let e=(n,o)=>t(o).update(s(n)).digest(),r=t({});return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=n=>t(n),e}function M(t=32){if(u&&typeof u.getRandomValues=="function")return u.getRandomValues(new Uint8Array(t));if(u&&typeof u.randomBytes=="function")return u.randomBytes(t);throw new Error("crypto.getRandomValues must be defined")}export{y as Hash,D as asyncLoop,d as byteSwap,j as byteSwap32,_ as byteSwapIfBE,I as bytesToHex,H as checkOpts,F as concatBytes,k as createView,C as hexToBytes,U as isBytes,x as isLE,h as nextTick,M as randomBytes,V as rotl,S as rotr,s as toBytes,T as u32,O as u8,m as utf8ToBytes,R as wrapConstructor,W as wrapConstructorWithOpts,v as wrapXOFConstructorWithOpts};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=utils.bundle.mjs.map